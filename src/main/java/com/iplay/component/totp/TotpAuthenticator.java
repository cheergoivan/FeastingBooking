package com.iplay.component.totp;

import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Date;
import java.util.concurrent.TimeUnit;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.stereotype.Component;

import com.iplay.configuration.totp.TotpConfigurationProperties;


/**
 * This class implements the TOTP(Time-Based One-Time Password) algorithm
 * described in RFC 6238.
 * 
 * @author Ivan,Zhang
 * @see <a href="https://tools.ietf.org/html/rfc6238" />
 *
 */
@Component
@EnableConfigurationProperties(TotpConfigurationProperties.class)
public class TotpAuthenticator {
	
	@Autowired
	private TotpConfigurationProperties totpConfig;
	

	/**
	 * generate a time-based one-time password with a given key at the receiving
	 * time.
	 * 
	 * @param key
	 *            the secret key in binary format.
	 * @return one-time password generated by the secret key at the receiving time
	 */
	public String generateTotp(byte[] key) {
		return calculateTotp(key, getTimeStepWindowFromTime(new Date().getTime()));
	}
	
	public String generateTotpUsingBase64Decoder(String secretKey){
		return generateTotp(Base64.decodeBase64(secretKey));
	}

	/**
	 * check the validity of the given secret key and the time-based one-time
	 * password.The validation system should compare OTPs not only with the
	 * receiving timestamp but also the past time-steps that are within the
	 * allowedValidationWinows.
	 * 
	 * @see <a href="https://tools.ietf.org/html/rfc6238#section-5.2" />
	 * 
	 * @param key
	 *            the secret key in binary format.
	 * @param totpFromProver
	 *            password from prover to be validated.
	 * @return true if the totpFromProver equals any totp in the
	 *         allowedValidationWindows.
	 * 
	 */
	public boolean validateTotp(byte[] key, String totpFromProver) {
		if (isTotp(totpFromProver)) {
			final long receivedTimeStepWindow = getTimeStepWindowFromTime(new Date().getTime());
			for (int i = 0
					- totpConfig.getAllowedPastValidationWindows(); i <= totpConfig.getAllowedFutureValidationWindows(); i++) {
				String totpCalculated = calculateTotp(key, receivedTimeStepWindow + i);
				if (totpCalculated.equals(totpFromProver)) {
					return true;
				}
			}
		}
		return false;
	}

	public boolean validateTotpUsingBase64Decoder(String secretKey, String totpFromProver){
		if(secretKey==null)
			return false;
		return validateTotp(Base64.decodeBase64(secretKey), totpFromProver);
	}
	

	/**
	 * Implementation of HOTP(HMAC-Based One-Time Password Algorithm),used to
	 * generate a password within a given hash algorithm and a timeStepWindow.
	 * if the keys are the same and time instants are in the same time-step
	 * window, the generated password is the same.
	 * </p>
	 * TOTP = HOTP(K,T).where T is an integer and represents the number of time
	 * steps between the initial counter time T0 and the current Unix time.
	 * </p>
	 * HOTP(K,C) = Truncate(HMAC-SHA-1(K,C)).see [RFC4226] for detailed
	 * definitions.
	 * </p>
	 * 
	 * @see	<a href="https://tools.ietf.org/html/rfc4226" />
	 * 
	 * @param key
	 *            the secret key in binary format.
	 * @param timeStepWindow
	 *            the time-step window of a time instance.
	 * @return one-time password generated by the secret key in the specific
	 *         time-step window.
	 */
	private String calculateTotp(byte[] key, long timeStepWindow) {
		byte[] data = new byte[8];
		long value = timeStepWindow;
		for (int i = 8; i-- > 0; value >>>= 8) {
			data[i] = (byte) value;
		}
		SecretKeySpec signKey = new SecretKeySpec(key, totpConfig.getCryptoAlgorithm());
		try {
			//Step 1:Generate an HMAC-SHA-1 value Let HS = HMAC-SHA-1(K,C)
			Mac mac = Mac.getInstance(totpConfig.getCryptoAlgorithm());
			mac.init(signKey);
			byte[] hmac_result = mac.doFinal(data);
			// Step 2: Generate a 4-byte string,from byte hmac_result[offset] 
			int offset = hmac_result[hmac_result.length - 1] & 0xF;
			int truncatedHash = (hmac_result[offset]  & 0x7f) << 24
	           | (hmac_result[offset+1] & 0xff) << 16
	           | (hmac_result[offset+2] & 0xff) <<  8
	           | (hmac_result[offset+3] & 0xff) ;
			//Step 3:Compute an HOTP value
			truncatedHash %= ((int) Math.pow(10, totpConfig.getTotpLength()));
			String totp = Integer.toString(truncatedHash);
			while (totp.length() < totpConfig.getTotpLength()) {
				totp = "0" + totp;
			}
			return totp;
		} catch (NoSuchAlgorithmException | InvalidKeyException ex) {
			ex.printStackTrace();
		}
		return "";
	}

	/**
	 * 
	 * @param time
	 *            instant in milliSeconds.
	 * @return the time-step window of a specific time instant.
	 */
	private long getTimeStepWindowFromTime(long milliSeconds) {
		return (milliSeconds - totpConfig.getTimeStart()) / TimeUnit.SECONDS.toMillis(totpConfig.getTimeWindowSize());
	}

	private boolean isTotp(String str) {
		if (str != null) {
			if (str.length() == totpConfig.getTotpLength()) {
				for (char c : str.toCharArray()) {
					if (!Character.isDigit(c)) {
						return false;
					}
				}
				return true;
			}
		}
		return false;
	}
	
}